fragment_downloaded_cb({"url":"howtox.html#page-description","fragment":"This page lists code snippets for common tasks. These are written\nmostly using the C compiler, but the same approach should work on\nalmost all other compilers.\nWhen first running Meson, set it in an environment variable.\nNote that environment variables like CC always refer to the native\ncompiler. That is, the compiler used to compile programs that run on\nthe current machine. The compiler used in cross compilation is set\nwith the cross file.\nThis behaviour is different from e.g. Autotools, where cross\ncompilation is done by setting CC to point to the cross compiler\n(such as /usr/bin/arm-linux-gnueabihf-gcc). The reason for this is\nthat Meson supports natively the case where you compile helper tools\n(such as code generators) and use the results during the\nbuild. Because of this Meson needs to know both the native and the\ncross compiler. The former is set via the environment variables or\nnative-files and the latter via the cross file only.\nNew in 0.53.0\nLike the compiler, the linker is selected via the <compiler variable>_LD\nenvironment variable, or through the <compiler entry>ld entry in a native\nor cross file. You must be aware of whether you're using a compiler that\ninvokes the linker itself (most compilers including GCC and Clang) or a\nlinker that is invoked directly (when using MSVC or compilers that act like\nit, including Clang-Cl). With the former cld or CC_LD should be the value\nto pass to the compiler's special argument (such as -fuse-ld with clang and\ngcc), with the latter it should be an executable, such as lld-link.exe.\nNOTE In meson 0.53.0 the ld entry in the cross/native file and the LD\nenvironment variable were used, this resulted in a large number of regressions\nand was changed in 0.53.1 to <lang>_ld and <comp variable>_LD.\nor\nor in a cross or native file:\nThe language version can also be set on a per-target basis.\nLots of people seem to do this manually with find_library('pthread')\nor something similar. Do not do that. It is not portable. Instead do\nthis.\nThe behavior is the same as with other build systems, with environment\nvariables during first invocation. Do not use these when you need to rebuild\nthe source\nFirst check which arguments to use.\nThen use it in a target.\nIf you want to use the arguments on all targets, then do this.\nconfigure_file preserves metadata so if your template file has\nexecute permissions, the generated file will have them too.\nFirst initialize the build directory with this command.\nThen issue the following commands.\nThe coverage report can be found in the meson-logs subdirectory.\nNote: Currently, Meson does not support generating coverage reports\nwith Clang.\nBy default the debug build does not use any optimizations. This is the\ndesired approach most of the time. However some projects benefit from\nhaving some minor optimizations enabled. GCC even has a specific\ncompiler flag -Og for this. To enable its use, just issue the\nfollowing command.\nThis causes all subsequent builds to use this command line argument.\nClang comes with a selection of analysis tools such as the address\nsanitizer. Meson\nhas native support for these with the b_sanitize option.\nAfter this you just compile your code and run the test suite. Address\nsanitizer will abort executables which have bugs so they show up as\ntest failures.\nInstall scan-build and configure your project. Then do this:\nYou can use the SCANBUILD environment variable to choose the\nscan-build executable.\nUsing profile guided optimization with GCC is a two phase\noperation. First we set up the project with profile measurements\nenabled and compile it.\nThen we need to run the program with some representative input. This\nstep depends on your project.\nOnce that is done we change the compiler flags to use the generated\ninformation and rebuild.\nAfter these steps the resulting binary is fully optimized.\nSome platforms (e.g. Linux) have a standalone math library. Other\nplatforms (pretty much everyone else) do not. How to specify that m\nis used only when needed?\nMeson can use the CMake find_package() ecosystem if CMake is installed.\nTo find a dependency with custom Find<name>.cmake, set the cmake_module_path\nproperty to the path in your project where the CMake scripts are stored.\nExample for a FindCmakeOnlyDep.cmake in a cmake subdirectory:\nThe cmake_module_path property is only needed for custom CMake scripts. System\nwide CMake scripts are found automatically.\nMore information can be found here\n"});