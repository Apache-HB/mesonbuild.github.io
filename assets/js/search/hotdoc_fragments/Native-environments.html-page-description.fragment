fragment_downloaded_cb({"url": "Native-environments.html#page-description", "fragment": "New in \nMeson has cross files for describing cross compilation environments for describing native environments it has equivalent native files \nNatives describe the build machine and can be used to override properties of non cross builds as well as properties that are marked as native in a cross build. \nThere are a couple of reasons you might want to use a native file to keep a persistent environment \nAll of the rules about cross files and changed settings apply to native files as well see here \nCurrently the only use of native files is to override native binaries. This includes the compilers and binaries collected with find_program and those used by dependencies that use a config tool instead of pkgconfig for detection like llvm config \nAs of paths and directories such as libdir can be defined in the native file in a paths section \nThese values will only be loaded when not cross compiling. Any arguments on the command line will override any options in the native file. For example passing libdir otherlibdir would result in a prefix of my prefix and a libdir of otherlibdir. \nUnlike cross file native files allow layering. More than one native file can be loaded with values from a previous file being overridden by the next. The intention of this is not overriding but to allow composing native files. \nFor example if there is a project using C and C python and LLVM and it needs to build with clang and and gcc x x and x expressing all of these configurations in monolithic configurations would result in different native files. By layering them it can be expressed by just native files. \nLike cross files native files may be installed to user or system wide locations defined as \nThe order of locations tried is as follows \nThese files are not intended to be shipped by distributions unless they are specifically for distribution packaging they are mainly intended for developers. \n"});