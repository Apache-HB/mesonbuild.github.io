fragment_downloaded_cb({"url":"Release-notes-for-0-53-0.html#page-description","fragment":"The new fs module can be used to examine the contents of the current\nfile system.\nmeson dist command line now gained --include-subprojects command line option.\nWhen enabled, the source tree of all subprojects used by the current build will\nalso be included in the final tarball. This is useful to distribute self contained\ntarball that can be built offline (i.e. --wrap-mode=nodownload).\nMeson now ships with predefined project templates for Dlang,\nFortran, Rust, Objective-C, and by passing the associated flags d,\nfortran, rust, objc to meson init --language.\nA new function summary() has been added to\nsummarize build configuration at the end of the build process.\nExample:\nOutput:\nPrevious to meson 0.52.0 you set the dynamic linker using compiler specific\nflags passed via language flags and hoped things worked out. In meson 0.52.0\nmeson started detecting the linker and making intelligent decisions about\nusing it. Unfortunately this broke choosing a non-default linker.\nNow there is a generic mechanism for doing this, you may use the LD\nenvironment variable (with normal meson environment variable rules), or add\nthe following to a cross or native file:\nAnd meson will select the linker if possible.\nnew in 0.53.0\nAkin to the c_std and cpp_std options, the fortran_std option sets Fortran compilers to warn or error on non-Fortran standard code.\nOnly the Gfortran and Intel Fortran compilers have support for this option.\nOther Fortran compilers ignore the fortran_std option.\nSupported values for fortran_std include:\nAdded the embed kwarg to the python module dependency function to select\nthe python library that can be used to embed python into an application.\nadded in 0.53.0:\nHistorically and through today, typical Scalapack setups have broken and incomplete pkg-config or\nFindScalapack.cmake. Meson handles finding Scalapack on setups including:\nIt is now possible to give a list of absolute paths where find_program() should\nalso search, using the dirs keyword argument.\nFor example on Linux /sbin and /usr/sbin are not always in the $PATH:\nWhen the respective tools are available, 'ctags', 'TAGS' and 'cscope'\ntargets will be generated by Meson, unless you have defined your own.\nKeys can now be any expression evaluating to a string value, not limited\nto string literals any more.\nWith this release even more CMake projects are supported via\nCMake subprojects due to these internal\nimprovements:\nsince 0.53.0, compiler.get_linker_id() allows retrieving a lowercase name for the linker.\nSince each compiler family can typically use a variety of linkers depending on operating system,\nthis helps users define logic for corner cases not otherwise easily handled.\nNative support for compiling and linking against the CUDA Toolkit using\nthe dependency function:\nSee the CUDA dependency for more information.\nThe new boolean option is called cpp_rtti.\ndependencies (--dependencies, intro-dependencies.json):\nscanning dependencies (--scan-dependencies):\ntests and benchmarks (--tests, --benchmarks, intro-tests.json,\nintro-benchmarks.json):\n\n\nlegacy for non-conforming code--this is especially important for Gfortran, which by default errors on old non-compliant Fortran code\n\nf95 for Fortran 95 compliant code.\n\nf2003 for Fortran 2003 compliant code.\n\nf2008 for Fortran 2008 compliant code.\n\nf2018 for Fortran 2018 compliant code.\n\n\nLinux: Intel MKL or OpenMPI + Netlib\nMacOS: Intel MKL or OpenMPI + Netlib\nWindows: Intel MKL (OpenMPI not available on Windows)\n\n\nUse the CMake file API for CMake >=3.14\nHandle the explicit dependencies via add_dependency\n\nBasic support for add_custom_target\n\nImproved add_custom_command support\nObject library support on Windows\n\n\nadded the version key\n\n\nadded the version key containing the required dependency version\n\n\nadded the protocol key\n\n"});