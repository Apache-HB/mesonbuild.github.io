fragment_downloaded_cb({"url":"ARM-performance-test.html#page-description","fragment":"Performance differences in build systems become more apparent on\nslower platforms. To examine this difference we compared the\nperformance of Meson with GNU Autotools. We took the GLib software\nproject and rewrote its build setup with Meson. GLib was chosen\nbecause it is a relatively large C code base which requires lots of\nlow level configuration.\nThe Meson version of the build system is not fully equivalent to the\noriginal Autotools one. It does not do all the same configuration\nsteps and does not build all the same targets. The biggest missing\npiece being internationalisation support with Gettext. However it does\nconfigure the system enough to build all C source and run all unit\ntests.\nAll measurements were done on a Nexus 4 smart phone running the latest\nUbuntu touch image (updated on September 9th 2013).\nThe first thing we measured was the time it took to run the configure step.\n\nMeson takes roughly 20 seconds whereas Autotools takes 220. This is a\ndifference of one order of magnitude. Autotools' time contains both\nautogen and configure. Again it should be remembered that Meson does\nnot do all the configure steps that Autotools does. It does do about\n90% of them and it takes just 10% of the time to do it.\nThen we measured the build times. Two parallel compilation processes\nwere used for both systems.\n\nOn desktop machines Ninja based build systems are 10-20% faster than\nMake based ones. On this platform the difference grows to 50%. The\ndifference is probably caused by Make's inefficient disk access\npatterns. Ninja is better at keeping both cores running all the time\nwhich yields impressive performance improvements.\n\nNext we measured the \"empty build\" case. That is, how long does it\ntake for the build system to detect that no changes need to be\nmade. This is one of the most important metrics of build systems\nbecause it places a hard limit on how fast you can iterate on your\ncode. Autotools takes 14 seconds to determine that no work needs to be\ndone. Meson (or, rather, Ninja) takes just one quarter of a second.\n\nOne step which takes quite a lot of time is linking. A common case is\nthat you are working on a library and there are tens of small test\nexecutables that link to it. Even if the compilation step would be\nfast, relinking all of the test executables takes time. It is common\nfor people to manually compile only one test application with a\ncommand such as make sometest rather than rebuild everything.\nMeson has an optimization for this case. Whenever a library is\nrebuilt, Meson inspects the ABI it exports. If it has not changed,\nMeson will skip all relinking steps as unnecessary. The difference\nthis makes can be clearly seen in the chart above. In that test the\nsource was fully built, then the file glib/gbytes.c was touched to\nforce the rebuild of the base glib shared library. As can be seen,\nAutotools then relinks all test executables that link with glib. Since\nMeson can detect that the ABI is the same it can skip those steps. The\nend result being that Meson is almost one hundred times faster on this\nvery common use case.\nOne of the main drawbacks of C and C++ compared to languages such as\nJava are long compilation times. However at least some of the blame\ncan be found in the build tools used rather than the languages\nthemselves or their compilers. Choosing proper tools can bring C and\nC++ compilation very close to instantaneous rebuilds. This has a\ndirect impact on programmer productivity.\n"});