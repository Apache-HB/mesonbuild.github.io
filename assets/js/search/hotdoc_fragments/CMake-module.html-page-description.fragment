fragment_downloaded_cb({"url":"CMake-module.html#page-description","fragment":"Note: the functionality of this module is governed by Meson's\nrules on mixing build systems.\nThis module provides helper tools for generating cmake package files.\nIt also supports the usage of CMake based subprojects, similar to\nthe normal meson subprojects.\nTo use this module, just do: cmake = import('cmake'). The\nfollowing functions will then be available as methods on the object\nwith the name cmake. You can, of course, replace the name cmake\nwith anything else.\nIt is generally recommended to use the latest Meson version and\nCMake >=3.17 for best compatibility. CMake subprojects will\nusually also work with older CMake versions. However, this can\nlead to unexpected issues in rare cases.\nUsing CMake subprojects is similar to using the \"normal\" meson\nsubprojects. They also have to be located in the subprojects\ndirectory.\nExample:\nThe subproject method is almost identical to the normal meson\nsubproject function. The only difference is that a CMake project\ninstead of a meson project is configured.\nAlso, project specific CMake options can be added with the cmake_options key.\nThe returned sub_proj supports the same options as a \"normal\" subproject.\nMeson automatically detects CMake build targets, which can be accessed with\nthe methods listed below.\nIt is usually enough to just use the dependency object returned by the\ndependency() method in the build targets. This is almost identical to\nusing declare_dependency() object from a normal meson subproject.\nIt is also possible to use executables defined in the CMake project as code\ngenerators with the target() method:\nIt should be noted that not all projects are guaranteed to work. The\nsafest approach would still be to create a meson.build for the\nsubprojects in question.\nThis object is returned by the subproject function described above\nand supports the following methods:\nThis function is the equivalent of the corresponding CMake function,\nit generates a name package version file.\nExample:\nThis function is the equivalent of the corresponding CMake function,\nit generates a name package configuration file from the input template file. Just like the cmake function\nin this file the @PACKAGE_INIT@ statement will be replaced by the appropriate piece of cmake code.\nThe equivalent PATH_VARS argument is given through the configuration parameter.\nExample:\nmeson.build:\nmyProject.cmake.in:\n\n\ndependency(target) returns a dependency object for any CMake target.\n\ninclude_directories(target) returns a meson include_directories()\nobject for the specified target. Using this function is not necessary\nif the dependency object is used.\n\ntarget(target) returns the raw build target.\n\ntarget_type(target) returns the type of the target as a string\n\ntarget_list() returns a list of all target names.\n\nget_variable(name) fetches the specified variable from inside\nthe subproject. Usually dependency() or target() should be\npreferred to extract build targets.\n\nfound returns true if the subproject is available, otherwise false\nnew in in 0.53.2\n\n\n\n\nname: the name of the package.\n\nversion: the version of the generated package file.\n\ncompatibility: a string indicating the kind of compatibility, the accepted values are\nAnyNewerVersion, SameMajorVersion, SameMinorVersion or ExactVersion.\nIt defaults to AnyNewerVersion. Depending on your cmake installation some kind of\ncompatibility may not be available.\n\ninstall_dir: optional installation directory, it defaults to $(libdir)/cmake/$(name)\n\n\n\n\nname: the name of the package.\n\ninput: the template file where that will be treated for variable substitutions contained in configuration.\n\ninstall_dir: optional installation directory, it defaults to $(libdir)/cmake/$(name).\n\nconfiguration: a configuration_data object that will be used for variable substitution in the template file.\n\n"});