fragment_downloaded_cb({"url":"Machine-files.html#page-description","fragment":"Cross and native files are nearly identical, but not completely. This is the\ndocumentation on the common values used by both, for the specific values of\none or the other see the cross compilation and native\nenvironments.\nThe following sections are allowed:\nThe binaries section contains a list of binaries. These can be used\ninternally by meson, or by the find_program function:\nCompilers and linkers are defined here using <lang> and <lang>_ld.\n<lang>_ld is special because it is compiler specific. For compilers like\ngcc and clang which are used to invoke the linker this is a value to pass to\ntheir \"choose the linker\" argument (-fuse-ld= in this case). For compilers\nlike MSVC and Clang-Cl, this is the path to a linker for meson to invoke,\nsuch as link.exe or lld-link.exe. Support for ls is new in 0.53.0\nchanged in 0.53.1 the ld variable was replaced by <lang>_ld, because it\n*regressed a large number of projects. in 0.53.0 the ld variable was used\ninstead.\nNative example:\nCross example:\nAn incomplete list of internally used programs that can be overridden here is:\nAs of 0.50.0 paths and directories such as libdir can be defined in the native\nfile in a paths section\nThese values will only be loaded when not cross compiling. Any arguments on the\ncommand line will override any options in the native file. For example, passing\n--libdir=otherlibdir would result in a prefix of /my prefix and a libdir of\notherlibdir.\nNew in native files in 0.54.0, always in cross files.\nIn addition to special data that may be specified in cross files, this\nsection may contain random key value pairs accessed using the\nmeson.get_external_property()\nNew for native files in 0.54.0\nThe properties section can contain any variable you like, and is accessed via\nmeson.get_external_property, or meson.get_cross_property.\nNative files allow layering (cross files can be layered since meson 0.52.0).\nMore than one native file can be loaded, with values from a previous file being\noverridden by the next. The intention of this is not overriding, but to allow\ncomposing native files. This composition is done by passing the command line\nargument multiple times:\nIn this case first.ini will be loaded, then second.ini, with values from\nsecond.ini replacing first.ini, and so on.\nFor example, if there is a project using C and C++, python 3.4-3.7, and LLVM\n5-7, and it needs to build with clang 5, 6, and 7, and gcc 5.x, 6.x, and 7.x;\nexpressing all of these configurations in monolithic configurations would\nresult in 81 different native files. By layering them, it can be expressed by\njust 12 native files.\n\nbinaries\npaths\nproperties\n\n\ncmake\ncups-config\ngnustep-config\ngpgme-config\nlibgcrypt-config\nlibwmf-config\nllvm-config\npcap-config\npkgconfig\nsdl2-config\nwx-config (or wx-3.0-config or wx-config-gtk)\n\n"});