fragment_downloaded_cb({"url": "Reference-manual.html#find_program", "fragment": "find_program \nprogram_name1 here is a string that can be an executable or script to be searched for in PATH or a script in the current source directory. \nprogram_name2 and later positional arguments are used as fallback strings to search for. This is meant to be used for cases where the program may have many alternative names such as foo and foo.py. The function will check for the arguments one by one and the first one that is found is returned. Meson versions earlier than only accept one argument. \nKeyword arguments are the following \nrequired By default required is set to true and Meson will abort if no program can be found. If required is set to false Meson continue even if none of the programs can be found. You can then use the found method on the returned object to check whether it was found or not. \nnative defines how this executable should be searched. By default it is set to false which causes Meson to first look for the executable in the cross file when cross building and if it is not defined there then from the system. If set to true the cross file is ignored and the program is only searched from the system. \nMeson will also autodetect scripts with a shebang line and run them with the executable interpreter specified in it both on Windows because the command invocator will reject the command otherwise and Unixes if the script file does not have the executable bit set Hence you must not manually add the interpreter while using this script as part of a list of commands. \nIf you need to check for a program in a non standard location you can just pass an absolute path to find_program e.g. setcap find_program setcap usr sbin setcap sbin setcap required false \nIt is also possible to pass an array to find_program in case you need to construct the set of paths to search on the fly \nThe returned object also has methods that are documented in the object methods section below. \n"});