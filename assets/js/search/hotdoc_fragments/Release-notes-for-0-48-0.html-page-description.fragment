fragment_downloaded_cb({"url": "Release-notes-for-0-48-0.html#page-description", "fragment": "Since the very beginning Meson has provided different project types to use such as debug and minsize. There is also a plain type that adds nothing by default but instead makes it the user s responsibility to add everything by hand. This works but is a bit tedious. \nIn this release we have added new new options to manually toggle e.g. optimization levels and debug info so those can be changed independently of other options. For example by default the debug buildtype has no optmization enabled at all. If you wish to use GCC s Og instead you could set it with the following command \nSimilarly we have added a toggle option to select the version of Visual Studio C runtime to use. By default it uses the debug runtime DLL debug builds and release DLL for release builds but this can be manually changed with the new base option b_vscrt. \nIf two calls to configure_file write to the same file Meson will print a WARNING message during configuration. For example \nThis will output \nThis keyword argument conflicts with capture and is meant for commands that are resource intensive and take a long time to finish. With the Ninja backend setting this will add this target to Ninja s console pool which has special properties such as not buffering stdout and serializing all targets in this pool. \nThe primary use case for this is to be able to run external commands that take a long time to exeute. Without setting this the user does not receive any feedback about what the program is doing. \nPreviously version constraints were only enforced for dependencies found using the pkg config dependency provider. These constraints now apply to dependencies found using any dependency provider. \nSome combinations of dependency host and method do not currently support discovery of the version. In these cases the dependency will not be found if a version constraint is applied otherwise the version method for the dependency object will return unknown \nIf discovering the version in one of these combinations is important to you and a method exists to determine the version in that case please file an issue with as much information as possible. \nA generic module python has been added in Meson and has a superset of the features implemented by the previous python3 module. \nIn most cases it is a simple matter of renaming \nbecomes \nDictionaries can now be added values from the second dictionary overrides values from the first \nYou can now specify scripts that are run as part of the dist target. An example usage would go like this \nA new command line option has been added fatal meson warnings. When enabled any warning message printed by Meson will be fatal and raise an exception. It is intended to be used by developers and CIs to easily catch deprecation warnings or any other potential issues. \nA set of new helpers have been added to the C and C compiler objects for checking GNU style function attributes. These are not just simpler to use they may be optimized to return fast on compilers that don t support these attributes. Currently this is true for MSVC. \nWould replace code like \nAdditionally a multi argument version has been added \nThe GNOME module can now generate a single gir for multiple libraries which is something g ir scanner supported but had not been exposed yet. \ngnome.generate_gir will now accept multiple positional arguments if none of these arguments are an Executable instance. \nA new module has been written to ease generation of hotdoc based documentation. It supports complex use cases such as hotdoc subprojects to create documentation portals and makes it straight forward to leverage full capabilities of hotdoc. \nSimple usage \nFilename substitutions like BASENAME and PLAINNAME were previously accepted but the name of the build target wasn t altered leading to colliding target names when using the substitution twice. i18n.merge_file now behaves as custom_target in this regard. \nIt has been a longstanding bug or let s call it a delayed bug fix that if yo do this \nThen the flag is used both in native and cross compilations. This is very confusing and almost never what you want. To fix this a new keyword native has been added to all functions that add arguments namely add_global_arguments add_global_link_arguments add_project_arguments and add_project_link_arguments that behaves like the following \nAlso remember that cross compilation is a property of each target. There can be target that are compiled with the native compiler and some which are compiled with the cross compiler. \nUnfortunately this change is backwards incompatible and may cause some projects to fail building. However this should be very rare in practice. \nIt is now possible to pass an executable to override_find_program if the overridden program is not used during configure. \nThis is particularly useful for fallback dependencies like Protobuf that also provide a tool like protoc. \nNow by default shared_library sets compatibility_version and current_version of a macOS dylib using the soversion. \nThis can be overriden by using the darwin_versions kwarg to shared_library As usual you can also pass this kwarg to library or build_target and it will be used in the appropriate circumstances. \ndependency version and other version constraints now handle versions containing non numeric characters better comparing versions using the rpmvercmp algorithm as using the pkg config autoconf macro PKG_CHECK_MODULES does \nThis is a breaking change for exact comparison constraints which rely on the previous comparison behaviour of extending the compared versions with elements up to the same length of separated elements. \nFor example a version of would previously match a version constraint of but no longer does being instead considered strictly greater. \nInstead use a version constraint which exactly compares with the precise version required e.g. \nBuild targets got a new keyword gnu_symbol_visibility that controls how symbols are exported from shared libraries. This is most commonly used to hide implementation symbols like this \nIn this case only symbols explicitly marked as visible in the source files get exported. \nTo enable this the following needs to be added to the wrap file \nThis allows you to declare an optional subproject. You can now call found on the return value of the subproject call to see if the subproject is available before calling get_variable to fetch information from it. \n"});