fragment_downloaded_cb({"url": "Dependencies.html#page-description", "fragment": "Building dependencies as subprojects \nDependencies with custom lookup functionality \nDependencies using config tools \nMany platforms do not provide a system package manager. On these systems dependencies must be compiled from source. Meson s subprojects make it simple to use system dependencies when they are available and to build dependencies manually when they are not. \nTo make this work the dependency must have Meson build definitions and it must declare its own dependency like this \nThen any project that wants to use it can write out the following declaration in their main meson.build file. \nWhat this declaration means is that first Meson tries to look up the dependency from the system such as by using pkg config If it is not available then it builds subproject named foo and from that extracts a variable foo_dep. That means that the return value of this function is either an external or an internal dependency object. Since they can be used interchangeably the rest of the build definitions do not need to care which one it is. Meson will take care of all the work behind the scenes to make this work. \nSome dependencies have specific detection logic. \nGeneric dependency names are case sensitive1 but these dependency names are matched case insensitively. The recommended style is to write them in all lower case. \nIn some cases more than one detection method exists and the method keyword may be used to select a detection method to use. The auto method uses any checking mechanisms in whatever order meson thinks is best. \ne.g. libwmf and CUPS provide both pkg config and config tool support. You can force one or another via the method keyword \nCUPS LLVM pcap WxWidgets libwmf and GnuStep either do not provide pkg config modules or additionally can be detected via a config tool cups config llvm config etc Meson has native support for these tools and they can be found like other dependencies \n"});