fragment_downloaded_cb({"url": "Dependencies.html#page-description", "fragment": "Very few applications are fully self contained but rather they use external libraries and frameworks to do their work. Meson makes it very easy to find and use external dependencies. Here is how one would use the zlib compression library. \nFirst Meson is told to find the external library zlib and error out if it is not found. The version keyword is optional and specifies a version requirement for the dependency. Then an executable is built using the specified dependency. Note how the user does not need to manually handle compiler or linker flags or deal with any other minutiae. \nIf you have multiple dependencies pass them as an array \nIf the dependency is optional you can tell Meson not to error out if the dependency is not found and then do further configuration. \nYou can pass the opt_dep variable to target construction functions whether the actual dependency was found or not. Meson will ignore non found dependencies. \nMeson also allows to get variables that are defined in the pkg config file. This can be done by using the get_pkgconfig_variable function. \nThese variables can also be redefined by passing the define_variable parameter which might be useful in certain situations \nThe dependency detector works with all libraries that provide a pkg config file. Unfortunately several packages don t provide pkg config files. Meson has autodetection support for some of these and they are described later in this page. \nYou can declare your own dependency objects that can be used interchangeably with dependency objects obtained from the system. The syntax is straightforward \nThis declares a dependency that adds the given include directories and static library to any target you use it in. \nMany platforms do not provide a system package manager. On these systems dependencies must be compiled from source. Meson s subprojects make it simple to use system dependencies when they are available and to build dependencies manually when they are not. \nTo make this work the dependency must have Meson build definitions and it must declare its own dependency like this \nThen any project that wants to use it can write out the following declaration in their main meson.build file. \nWhat this declaration means is that first Meson tries to look up the dependency from the system such as by using pkg config If it is not available then it builds subproject named foo and from that extracts a variable foo_dep. That means that the return value of this function is either an external or an internal dependency object. Since they can be used interchangeably the rest of the build definitions do not need to care which one it is. Meson will take care of all the work behind the scenes to make this work. \nYou can use the keyword method to let meson know what method to use when searching for the dependency. The default value is auto. Aditional dependencies methods are pkg config config tool cmake system sysconfig qmake extraframework and dub. \nThe dependency method order for auto is \nMeson can use the CMake find_package function to detect dependencies with the builtin Find NAME cmake modules and exported project configurations usually in usr lib cmake Meson is able to use both the old style NAME _LIBRARIES variables as well as imported targets. \nIt is possible to manually specify a list of CMake targets that should be used with the modules property. Howerver this step is optional since meson tries to automatically guess the correct target based on the name of the dependency. \nDepending on the dependency it may be neccessary to explicitly specify a CMake target with the modules property if meson is unable to guess it automatically. \nIt is also possible to reuse existing Find name cmake files with the cmake_module_path property. Using this property is equivalent to setting the CMAKE_MODULE_PATH variable in CMake. The path s given to cmake_module_path should all be relative to the project source directory. Absolute paths should only be used if the CMake files are not stored in the project itself. \nAdditional CMake parameters can be specified with the cmake_args property. \nPlease understand that meson is only able to find dependencies that exist in the local Dub repository. You need to manually fetch and build the target dependencies. \nFor urld. \nOther thing you need to keep in mind is that both meson and Dub need to be using the same compiler. This can be achieved using Dub s compiler argument and or manually setting the DC environment variable when running meson. \nSome dependencies have specific detection logic. \nGeneric dependency names are case sensitive1 but these dependency names are matched case insensitively. The recommended style is to write them in all lower case. \nIn some cases more than one detection method exists and the method keyword may be used to select a detection method to use. The auto method uses any checking mechanisms in whatever order meson thinks is best. \ne.g. libwmf and CUPS provide both pkg config and config tool support. You can force one or another via the method keyword \nCUPS LLVM pcap WxWidgets libwmf GCrypt GPGME and GnuStep either do not provide pkg config modules or additionally can be detected via a config tool cups config llvm config libgcrypt config etc Meson has native support for these tools and they can be found like other dependencies \nUse the modules keyword to list frameworks required e.g. \nThese dependencies can never be found for non OSX hosts. \nBoost is not a single dependency but rather a group of different libraries. To use Boost headers only libraries simply add Boost as a dependency. \nTo link against boost with Meson simply list which libraries you would like to use. \nYou can call dependency multiple times with different modules and use those to link against your targets. \nIf your boost headers or libraries are in non standard locations you can set the BOOST_ROOT BOOST_INCLUDEDIR and or BOOST_LIBRARYDIR environment variables. \nYou can set the argument threading to single to use boost libraries that have been compiled for single threaded use instead. \nmethod may be auto config tool pkg config cmake or extraframework. \nadded \nCoarrays are a Fortran language intrinsic feature enabled by dependency coarray \nGCC will use OpenCoarrays if present to implement coarrays while Intel and NAG use internal coarray support. \nThis finds the OpenGL library in a way appropriate to the platform. \nmethod may be auto pkg config or system. \nGTest and GMock come as sources that must be compiled as part of your project. With Meson you don t have to care about the details just pass gtest or gmock to dependency and it will do everything for you. If you want to use GMock it is recommended to use GTest as well as getting it to work standalone is tricky. \nYou can set the main keyword argument to true to use the main function provided by GTest \nadded \nHDF5 is supported for C C and Fortran. Because dependencies are language specific you must specify the requested language using the language keyword argument i.e. \nMeson uses pkg config to find HDF5. The standard low level HDF5 function and the HL high level HDF5 functions are linked for each language. \nadded \nmethod may be auto config tool or pkg config. \nMeson has native support for LLVM going back to version LLVM version It supports a few additional features compared to other config tool based dependencies. \nAs of Meson supports the static keyword argument for LLVM. Before this LLVM would always dynamically link while older versions would statically link due to a quirk in llvm config. \nMeson wraps LLVM s concept of components in it s own modules concept. When you need specific components you add them as modules as meson will do the right thing \nAs of it can also take optional modules these will affect the arguments generated for a static link \nadded \nMPI is supported for C C and Fortran. Because dependencies are language specific you must specify the requested language using the language keyword argument i.e. \nMeson prefers pkg config for MPI but if your MPI implementation does not provide them it will search for the standard wrapper executables mpic mpicxx mpic mpifort mpif90 mpif77. If these are not in your path they can be specified by setting the standard environment variables MPICC MPICXX MPIFC MPIF90 or MPIF77 during configuration. \nadded \nNetCDF is supported for C C and Fortran. Because NetCDF dependencies are language specific you must specify the requested language using the language keyword argument i.e. \nMeson uses pkg config to find NetCDF. \nadded \nThis dependency selects the appropriate compiler flags and or libraries to use for OpenMP support. \nThe language keyword may used. \nadded \nmethod may be auto config tool or pkg config. \nadded \nmethod may be auto config tool or pkg config. \nadded \nmethod may be auto config tool or pkg config. \nPython3 is handled specially by meson \nNote that python3 found by this dependency might differ from the one used in python3 module because modules uses the current interpreter but dependency tries pkg config first. \nmethod may be auto extraframework pkg config or sysconfig \nMeson has native Qt support. Its usage is best demonstrated with an example. \nHere we have an UI file created with Qt Designer and one source and header file each that require preprocessing with the moc tool. We also define a resource file to be compiled with rcc. We just have to tell Meson which files are which and it will take care of invoking all the necessary tools in the correct order which is done with the preprocess method of the qt5 module. Its output is simply put in the list of sources for the target. The modules keyword of dependency works just like it does with Boost. It tells which subparts of Qt the program uses. \nYou can set the main keyword argument to true to use the WinMain function provided by qtmain static library this argument does nothing on platforms other than Windows \nSetting the optional private_headers keyword to true adds the private header include path of the given module s to the compiler flags. since v0.47.0 \nNote using private headers in your project is a bad idea do so at your own risk. \nmethod may be auto pkg config or qmake. \nSDL2 can be located using pkg confg the sdl2 config config tool or as an OSX framework. \nmethod may be auto config tool extraframework or pkg config. \nThis dependency selects the appropriate compiler flags and or libraries to use for thread support. \nSee threads. \nMeson will find valgrind using pkg config but only uses the compilation flags and avoids trying to link with it s non PIC static libs. \nadded \nVulkan can be located using pkg config or the VULKAN_SDK environment variable. \nmethod may be auto pkg config or system. \nSimilar to Boost WxWidgets is not a single library but rather a collection of modules. WxWidgets is supported via wx config. Meson substitutes modules to wx config invocation it generates \nadded \nShaderc currently does not ship with any means of detection. Nevertheless Meson can try to detect it using pkg config but will default to looking for the appropriate library manually. If the static keyword argument is true shaderc_combined is preferred. Otherwise shaderc_shared is preferred. Note that it is not possible to obtain the shaderc version using this method. \nmethod may be auto pkg config or system. \n"});