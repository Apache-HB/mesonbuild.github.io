fragment_downloaded_cb({"url":"Simd-module.html#page-description","fragment":"This module provides helper functionality to build code with SIMD instructions.\nAvailable since 0.42.0.\nNote:Â this module is unstable. It is only provided as a technology preview.\nIts API may change in arbitrary ways between releases or it might be removed\nfrom Meson altogether.\nThis module is designed for the use case where you have an algorithm with one\nor more SIMD implementation and you choose which one to use at runtime.\nThe module provides one method, check, which is used like this:\nHere the individual files contain the accelerated versions of the functions\nin question. The compiler keyword argument takes the compiler you are\ngoing to use to compile them. The function returns an array with two values.\nThe first value is a bunch of libraries that contain the compiled code. Any\nSIMD code that the compiler can't compile (for example, Neon instructions on\nan x86 machine) are ignored. You should pass this value to the desired target\nusing link_with. The second value is a configuration_data object that\ncontains true for all the values that were supported. For example if the\ncompiler did support sse2 instructions, then the object would have HAVE_SSE2\nset to 1.\nGenerating code to detect the proper instruction set at runtime is\nstraightforward. First you create a header with the configuration object and\nthen a chooser function that looks like this:\nEach source file provides two functions, the xxx_available function to query\nwhether the CPU currently in use supports the instruction set and\nxxx_accelerated_function that is the corresponding accelerated\nimplementation.\nAt the end of this function the function pointer points to the fastest\navailable implementation and can be invoked to do the computation.\n"});