fragment_downloaded_cb({"url": "FAQ.html#page-description", "fragment": "See also How do I do X in Meson. \nWhen the name was originally chosen there were two main limitations there must not exist either a Debian package or a Sourceforge project of the given name. This ruled out tens of potential project names. At some point the name Gluon was considered. Gluons are elementary particles that hold protons and neutrons together much like a build system s job is to take pieces of source code and a compiler and bind them to a complete whole. \nUnfortunately this name was taken too. Then the rest of subatomic particles were examined and Meson was found to be available. \nThis will set up everything on your behalf. People coming from Autotools or CMake want to do this by looking for libpthread.so manually. Don t do that it has tricky corner cases especially when cross compiling. \nStarting from version Meson is available from the Python Package Index so installing it simply a matter of running this command \nIf you don t have access to PyPI that is not a problem either. Meson has been designed to be easily runnable from an extracted source tarball or even a git checkout. First you need to download Meson. Then use this command to set up you build instead of plain meson. \nAfter this you don t have to care about invoking Meson any more. It remembers where it was originally invoked from and calls itself appropriately. As a user the only thing you need to do is to cd into your build directory and invoke ninja. \nInstead of specifying files explicitly people seem to want to do this \nMeson does not support this syntax and the reason for this is simple. This can not be made both reliable and fast. By reliable we mean that if the user adds a new source file to the subdirectory Meson should detect that and make it part of the build automatically. \nOne of the main requirements of Meson is that it must be fast. This means that a no op build in a tree of source files must take no more than a fraction of a second. This is only possible because Meson knows the exact list of files to check. If any target is specified as a wildcard glob this is no longer possible. Meson would need to re evaluate the glob every time and compare the list of files produced against the previous list. This means inspecting the entire source tree because the glob pattern could be src cpp or something like that This is impossible to do efficiently. \nThe main backend of Meson is Ninja which does not support wildcard matches either and for the same reasons. \nBecause of this all source files must be specified explicitly. \nIf the tradeoff between reliability and convenience is acceptable to you then Meson gives you all the tools necessary to do wildcard globbing. You are allowed to run arbitrary commands during configuration. First you need to write a script that locates the files to compile. Here s a simple shell script that writes all c files in the current directory one per line. \nThen you need to run this script in your Meson file convert the output into a string array and use the result in a target. \nThe script can be any executable so it can be written in shell Python Lua Perl or whatever you wish. \nAs mentioned above the tradeoff is that just adding new files to the source directory does not add them to the build automatically. To add them you need to tell Meson to reinitialize itself. The simplest way is to touch the meson.build file in your source root. Then Meson will reconfigure itself next time the build command is run. Advanced users can even write a small background script that utilizes a filesystem event queue such as inotify to do this automatically. \nThe answer is almost always subdir. Subproject exists for a very specific use case embedding external dependencies into your build process. As an example suppose we are writing a game and wish to use SDL. Let us further suppose that SDL comes with a Meson build definition. Let us suppose even further that we don t want to use prebuilt binaries but want to compile SDL for ourselves. \nIn this case you would use subproject. The way to do it would be to grab the source code of SDL and put it inside your own source tree. Then you would do sdl subproject sdl which would cause Meson to build SDL as part of your build and would then allow you to link against it or do whatever else you may prefer. \nFor every other use you would use subdir. As an example if you wanted to build a shared library in one dir and link tests against it in another dir you would do something like this \nBecause Make is slow. This is not an implementation issue Make simply can not be made fast. For further info we recommend you read this post by Evan Martin the author of Ninja. Makefiles also have a syntax that is very unpleasant to write which makes them a big maintenance burden. \nThe only reason why one would use Make instead of Ninja is working on a platform that does not have a Ninja port. Even in this case it is an order of magnitude less work to port Ninja than it is to write a Make backend for Meson. \nJust use Ninja you ll be happier that way. I guarantee it. \nA related question to this is Why is Meson s configuration language not Turing complete \nThere are many good reasons for this most of which are summarized on this web page Against The Use Of Programming Languages in Configuration Files. \nIn addition to those reasons not exposing Python or any other real programming language makes it possible to port Meson s implementation to a different language. This might become necessary if for example Python turns out to be a performance bottleneck. This is an actual problem that has caused complications for GNU Autotools and SCons. \nEither by using GCC symbol visibility or by writing a linker script. This has the added benefit that your symbol definitions are in a standalone file instead of being buried inside your build definitions. An example can be found here. \nWith GCC all symbols on shared libraries are exported automatically unless you specify otherwise. With MSVC no symbols are exported by default. If your shared library exports no symbols MSVC will silently not produce an import library file leading to failures. The solution is to add symbol visibility definitions as specified in GCC wiki. \nYou probably did the equivalent to this \nMeson is explicit. In this particular case it will not automatically split your strings at whitespaces instead it will take it as is and work extra hard to pass it to the compiler unchanged including quoting it properly over shell invocations. This is mandatory to make e.g. files with spaces in them work flawlessly. To pass multiple command line arguments you need to explicitly put them in an array like this \nYou probably had a project that looked something like this \nThis defaults to c on GCC compilers. Suppose you want to use c instead so you change the definition to this \nBut when you recompile it still uses c The reason for this is that default options are only looked at when you are setting up a build directory for the very first time. After that the setting is considered to have a value and thus the default value is ignored. To change an existing build dir to c either reconfigure your build dir with meson configure or delete the build dir and recreate it from scratch. \nThe reason we don t automatically change the option value when the default is changed is that it is impossible to know to do that reliably. The actual question that we need to solve is if the option s value is foo and the default value is bar should we change the option value to bar also There are many choices \nif the user has changed the value themselves from the default then we must not change it back \nif the user has not changed the value but changes the default value then this section s premise would seem to indicate that the value should be changed \nsuppose the user changes the value from the default to foo then back to bar and then changes the default value to bar the correct step to take is ambiguous by itself \nIn order to solve the latter question we would need to remember not only the current and old value but also all the times the user has changed the value and from which value to which other value. Since people don t remember their own actions that far back toggling between states based on long history would be confusing. \nBecause of this we do the simple and understandable thing default values are only defaults and will never affect the value of an option once set. \nIt does not. In order for Meson to download anything from the net while building two conditions must be met. \nFirst of all there needs to be a wrap file with a download URL in the subprojects directory. If one does not exist Meson will not download anything. \nThe second requirement is that there needs to be an explicit subproject invocation in your meson.build files. Either subproject foobar or dependency foobar fallback foobar foo_dep If these declarations either are not in any build file or they are not called due to e.g. if else then nothing is downloaded. \nIf this is not sufficient for you starting from release Meson has a option called wrap mode which can be used to disable wrap downloads altogether with wrap mode nodownload. You can also disable dependency fallbacks altogether with wrap mode nofallback which also implies the nodownload option. \nIf on the other hand you want meson to always use the fallback for dependencies even when an external dependency exists and could satisfy the version requirements for example in order to make sure your project builds when fallbacks are used you can use wrap mode forcefallback since \nBecause build systems are special in ways normal applications aren t. \nPerhaps the biggest limitation is that because Meson is used to build software at the very lowest levels of the OS it is part of the core bootstrap for new systems. Whenever support for a new CPU architecture is added Meson must run on the system before software using it can be compiled natively. This requirement adds two hard limitations. \nThe first one is that Meson must have the minimal amount of dependencies because they must all be built during the bootstrap to get Meson to work. \nThe second is that Meson must support all CPU architectures both existing and future ones. As an example many new programming languages have only an LLVM based compiler available. LLVM has limited CPU support compared to say GCC and thus bootstrapping Meson on such platforms would first require adding new processor support to LLVM. This is in most cases unfeasible. \nA further limitation is that we want developers on as many platforms as possible to submit to Meson development using the default tools provided by their operating system. In practice what this means is that Windows developers should be able to contribute using nothing but Visual Studio. \nAt the time of writing April there are only three languages that could fullfill these requirements \nOut of these we have chosen Python because it is the best fit for our needs. \nMeson needs to know several details about each compiler in order to compile code with it. These include things such as which compiler flags to use for each option and how to detect the compiler from its output. This information can not be input via a configuration file instead it requires changes to Meson s source code that need to be submitted to Meson master repository. In theory you can run your own forked version with custom patches but that s not good use of your time. Please submit the code upstream so everyone can use the toolchain. \nThe steps for adding a new compiler for an existing language are roughly the following. For simplicity we re going to assume a C compiler. \nCreate a new class with a proper name in mesonbuild compilers c.py. Look at the methods that other compilers for the same language have and duplicate what they do. \nIf the compiler can only be used for cross compilation make sure to flag it as such see existing compiler classes for examples \nAdd detection logic to mesonbuild environment.py look for a method called detect_c_compiler. \nRun the test suite and fix issues until the tests pass. \nSubmit a pull request add the result of the test suite to your MR linking an existing page is fine \nIf the compiler is freely available consider adding it to the CI system. \nThe naming convention for static libraries on Windows is usually foo.lib. Unfortunately import libraries are also called foo.lib. \nThis causes filename collisions with the default library type where we build both shared and static libraries and also causes collisions during installation since all libraries are installed to the same directory by default. \nTo resolve this we decided to default to creating static libraries of the form libfoo.a when building with MSVC. This has the following advantages \nIf for some reason you really need your project to output static libraries of the form foo.lib when building with MSVC you can set the name_prefix kwarg to and the name_suffix kwarg to lib To get the default behaviour for each you can either not specify the kwarg or pass an empty array to it. \n"});