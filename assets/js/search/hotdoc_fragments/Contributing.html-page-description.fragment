fragment_downloaded_cb({"url":"Contributing.html#page-description","fragment":"A large fraction of Meson is contributed by people outside the core\nteam. This documentation explains some of the design rationales of\nMeson as well as how to create and submit your patches for inclusion\nto Meson.\nThank you for your interest in participating to the development.\nAll changes must be submitted as pull requests to\nGithub. This causes them\nto be run through the CI system. All submissions must pass a full CI\ntest run before they are even considered for submission.\nIt is possible that while your pull request is being reviewed, other\nchanges are committed to master that cause merge conflicts that must\nbe resolved. The basic rule for this is very simple: keep your pull\nrequest up to date using rebase only.\nDo not merge head back to your branch. Any merge commits in your pull\nrequest make it not acceptable for merging into master and you must\nremove them.\nEvery new feature requires some extra steps, namely:\nThe kind of review and acceptance any merge proposal gets depends on\nthe changes it contains. All pull requests must be reviewed and\naccepted by someone with commit rights who is not the original\nsubmitter. Merge requests can be roughly split into three different\ncategories.\nThe first one consists of MRs that only change the markdown\ndocumentation under docs/markdown. Anyone with access rights can\npush changes to these directly to master. For major changes it is\nstill recommended to create a MR so other people can comment on it.\nThe second group consists of merges that don't change any\nfunctionality, fixes to the CI system and bug fixes that have added\nregression tests (see below) and don't change existing\nfunctionality. Once successfully reviewed anyone with merge rights can\nmerge these to master.\nThe final kind of merges are those that add new functionality or\nchange existing functionality in a backwards incompatible way. These\nrequire the approval of the project lead.\nIn a simplified list form the split would look like the following:\nMeson's merge strategy should fullfill the following guidelines:\npreserve as much history as possible\nhave as little junk in the repo as possible\neverything in the \"master lineage\" should always pass all tests\nThese goals are slightly contradictory so the correct thing to do\noften requires some judgement on part of the person doing the\nmerge. Github provides three different merge options, The rules of\nthumb for choosing between them goes like this:\nsingle commit pull requests should always be rebased\na pull request with one commit and one \"fixup\" commit (such as\ntesting something to see if it passes CI) should be squashed\nlarge branches with many commits should be merged with a merge\ncommit, especially if one of the commits does not pass all tests\n(which happens in e.g. large and difficult refactorings)\nIf in doubt, ask for guidance on IRC.\nAll new features must come with automatic tests that thoroughly prove\nthat the feature is working as expected. Similarly bug fixes must come\nwith a unit test that demonstrates the bug, proves that it has been\nfixed and prevents the feature from breaking in the future.\nSometimes it is difficult to create a unit test for a given bug. If\nthis is the case, note this in your pull request. We may permit bug\nfix merge requests in these cases. This is done on a case by case\nbasis. Sometimes it may be easier to write the test than convince the\nmaintainers that one is not needed. Exercise judgment and ask for help\nin problematic cases.\nThe tests are split into two different parts: unit tests and full\nproject tests. To run all tests, execute ./run_tests.py. Unit tests\ncan be run with ./run_unittests.py and project tests with\n./run_project_tests.py.\nEach project test is a standalone project that can be compiled on its\nown. They are all in test cases subdirectory. The simplest way to\nrun a single project test is to do something like ./meson.py test\\ cases/common/1\\ trivial builddir. The one exception to this is test cases/unit directory discussed below.\nThe test cases in the common subdirectory are meant to be run always\nfor all backends. They should only depend on C and C++, without any\nexternal dependencies such as libraries. Tests that require those are\nin the test cases/frameworks directory. If there is a need for an\nexternal program in the common directory, such as a code generator, it\nshould be implemented as a Python script. The goal of test projects is\nalso to provide sample projects that end users can use as a base for\ntheir own projects.\nAll project tests follow the same pattern: they are compiled, tests\nare run and finally install is run. Passing means that building and\ntests succeed and installed files match the installed_files.txt file\nin the test's source root. Any tests that require more thorough\nanalysis, such as checking that certain compiler arguments can be\nfound in the command line or that the generated pkg-config files\nactually work should be done with a unit test.\nProjects needed by unit tests are in the test cases/unit\nsubdirectory. They are not run as part of ./run_project_tests.py.\nMeson uses several continuous integration testing systems that have slightly\ndifferent interfaces for indicating a commit should be skipped.\nContinuous integration systems currently used:\nTo promote consistent naming policy, use:\nThe docs directory contains the full documentation that will be used\nto generate the Meson web site. Every change\nin functionality must change the documentation pages. In most cases\nthis means updating the reference documentation page but bigger\nchanges might need changes in other documentation, too.\nAll new functionality needs to have a mention in the release\nnotes. These features should be written in standalone files in the\ndocs/markdown/snippets directory. The release manager will combine\nthem into one page when doing the release.\nIntegration tests should be disabled for\ndocumentation-only commits by putting [skip ci] into commit title.\nReviewers should ask contributors to put [skip ci] into the title because\ntests are run again after merge for master.\nMeson follows the basic Python coding style. Additional rules are the\nfollowing:\nMeson uses Flake8 for style guide enforcement. The Flake8 options for\nthe project are contained in setup.cfg.\nTo run Flake8 on your local clone of Meson:\nTo run it automatically before committing:\nMeson has a bunch of test code in several languages. The rules for\nthose are simple.\nThe goal of Meson is to be as easily usable as possible. The user\nexperience should be \"get Python3 and Ninja, run\", even on\nWindows. Unfortunately this means that we can't have dependencies on\nprojects outside of Python's standard library. This applies only to\ncore functionality, though. For additional helper programs etc the use\nof external dependencies may be ok. If you feel that you are dealing\nwith this kind of case, please contact the developers first with your\nuse case.\nThe main design principle of Meson is that the definition language is\nnot Turing complete. Any change that would make Meson Turing complete\nis automatically rejected. In practice this means that defining your\nown functions inside meson.build files and generalised loops will\nnot be added to the language.\nNo you don't. All contributions are welcome.\nMeson operates in much the same way as functional programming\nlanguages. It has inputs, which include meson.build files, values of\noptions, compilers and so on. These are passed to a function, which\ngenerates output build definition. This function is pure, which means that:\nThe latter one is important, because it enforces that there is no way\nfor \"secret state\" to pass between consecutive invocations of\nMeson. This is the reason why, for example, there is no set_option\nfunction even though there is a get_option one.\nIf this were not the case, we could never know if the build output is\n\"stable\". For example suppose there were a set_option function and a\nboolean variable flipflop. Then you could do this:\nThis piece of code would never converge. Every Meson run would change\nthe value of the option and thus the output you get out of this build\ndefinition would be random.\nMeson does not permit this by forbidding these sorts of covert channels.\nThere is one exception to this rule. Users can call into external\ncommands with run_command. If the output of that command does not\nbehave like a pure function, this problem arises. Meson does not try\nto guard against this case, it is the responsibility of the user to\nmake sure the commands they run behave like pure functions.\nEnvironment variables are like global variables, except that they are\nalso hidden by default. Envvars should be avoided whenever possible,\nall functionality should be exposed in better ways such as command\nline switches.\nAll features should follow the 90/9/1 rule. 90% of all use cases\nshould be easy, 9% should be possible and it is totally fine to not\nsupport the final 1% if it would make things too complicated.\nAny build directory will have at most two toolchains: one native and\none cross.\nPrefer specific solutions to generic frameworks. Solve the end\nuser's problems rather than providing them tools to do it\nthemselves.\n\nMust include a project test under test cases/, or if that's not\npossible or if the test requires a special environment, it must go\ninto run_unittests.py.\nMust be registered with the FeatureChecks framework\nthat will warn the user if they try to use a new feature while\ntargetting an older meson version.\nNeeds a release note snippet inside docs/markdown/snippets/ with\na heading and a brief paragraph explaining what the feature does\nwith an example.\n\n\nmembers with commit access can do:\n\ndocumentation changes (directly to master if warranted)\nbug fixes that don't change functionality\nrefactorings\nnew dependency types\nnew tool support (e.g. a new Doxygen-kind of tool)\nsupport for new compilers to existing languages\n\n\nproject leader decision is needed for:\n\nnew modules\nnew functions in the Meson language\nsyntax changes for Meson files\nchanges breaking backwards compatibility\nsupport for new languages\n\n\n\n\ndocumentation changes (directly to master if warranted)\nbug fixes that don't change functionality\nrefactorings\nnew dependency types\nnew tool support (e.g. a new Doxygen-kind of tool)\nsupport for new compilers to existing languages\n\n\nnew modules\nnew functions in the Meson language\nsyntax changes for Meson files\nchanges breaking backwards compatibility\nsupport for new languages\n\n\n\npreserve as much history as possible\n\n\nhave as little junk in the repo as possible\n\n\neverything in the \"master lineage\" should always pass all tests\n\n\n\n\nsingle commit pull requests should always be rebased\n\n\na pull request with one commit and one \"fixup\" commit (such as\ntesting something to see if it passes CI) should be squashed\n\n\nlarge branches with many commits should be merged with a merge\ncommit, especially if one of the commits does not pass all tests\n(which happens in e.g. large and difficult refactorings)\n\n\n\n\nTravis-CI\nallows [skip ci] anywhere in the commit messages.\n\nAzure Pipelines\nallows ***NO_CI*** in the commit message.\n\nSider\nruns Flake8 (see below)\n\n\n\n[skip ci] in the commit title if you want to disable all integration tests\n\n\nindent 4 spaces, no tabs ever\nindent meson.build files with two spaces\ntry to keep the code as simple as possible\ncontact the mailing list before embarking on large scale projects\nto avoid wasted effort\n\n\nindent 4 spaces, no tabs ever\nbrace always on the same line as if/for/else/function definition\n\n\nfor any given input the output is always the same\nrunning Meson twice in a row always produce the same output in both runs\n\n\n\nAll features should follow the 90/9/1 rule. 90% of all use cases\nshould be easy, 9% should be possible and it is totally fine to not\nsupport the final 1% if it would make things too complicated.\n\n\nAny build directory will have at most two toolchains: one native and\none cross.\n\n\nPrefer specific solutions to generic frameworks. Solve the end\nuser's problems rather than providing them tools to do it\nthemselves.\n\n\n"});