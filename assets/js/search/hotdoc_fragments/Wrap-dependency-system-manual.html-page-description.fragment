fragment_downloaded_cb({"url":"Wrap-dependency-system-manual.html#page-description","fragment":"One of the major problems of multiplatform development is wrangling\nall your dependencies. This is easy on Linux where you can use system\npackages but awkward on other platforms. Most of those do not have a\npackage manager at all. This has been worked around by having third\nparty package managers. They are not really a solution for end user\ndeployment, because you can't tell them to install a package manager\njust to use your app. On these platforms you must produce\nself-contained applications.\nThe traditional approach to this has been to bundle dependencies\ninside your own project. Either as prebuilt libraries and headers or\nby embedding the source code inside your source tree and rewriting\nyour build system to build them as part of your project.\nThis is both tedious and error prone because it is always done by\nhand. The Wrap dependency system of Meson aims to provide an automated\nway to do this.\nMeson has a concept of subprojects. They are a way\nof nesting one Meson project inside another. Any project that builds\nwith Meson can detect that it is built as a subproject and build\nitself in a way that makes it easy to use (usually this means as a\nstatic library).\nTo use this kind of a project as a dependency you could just copy and\nextract it inside your project's subprojects directory.\nHowever there is a simpler way. You can specify a Wrap file that tells Meson\nhow to download it for you. If you then use this subproject in your build,\nMeson will automatically download and extract it during build. This makes\nsubproject embedding extremely easy.\nAll wrap files must have a name of <project_name>.wrap form and be in subprojects dir.\nCurrently Meson has three kinds of wraps:\nAn example wrap file for libfoobar would have a name libfoobar.wrap\nand would look like this:\nsource_hash is sha256sum of source_filename.\nSince 0.49.0 if source_filename is found in project's\nsubprojects/packagecache directory, it will be used instead of downloading the\nsource, even if --wrap-mode option is set to nodownload. The file's hash will\nbe checked.\nUnfortunately most software projects in the world do not build with\nMeson. Because of this Meson allows you to specify a patch URL. This\nworks in much the same way as Debian's distro patches. That is, they\nare downloaded and automatically applied to the subproject. These\nfiles contain a Meson build definition for the given subproject.\nA wrap file with an additional patch URL would look like this:\nIn this example the Wrap manager would download the patch and unzip it\nin libfoobar's directory.\nThis approach makes it extremely simple to embed dependencies that\nrequire build system changes. You can write the Meson build definition\nfor the dependency in total isolation. This is a lot better than doing\nit inside your own source tree, especially if it contains hundreds of\nthousands of lines of code. Once you have a working build definition,\njust zip up the Meson build files (and others you have changed) and\nput them somewhere where you can download them.\nSince 0.49.0 if patch_filename is found in project's\nsubprojects/packagecache directory, it will be used instead of downloading the\npatch, even if --wrap-mode option is set to nodownload. The file's hash will\nbe checked.\nThis type of wrap allows branching subprojects directly from git.\nThe above mentioned scheme assumes that your subproject is working off\npackaged files. Sometimes you want to check code out directly from\nGit. Meson supports this natively. All you need to do is to write a\nslightly different wrap file.\nThe format is straightforward. The only thing to note is the revision\nelement that can have one of two values. The first is head which\nwill cause Meson to track the master head (doing a repull whenever the\nbuild definition is altered). The second type is a commit hash or a\ntag. In this case Meson will use the commit specified (with git checkout [hash/tag id]).\nNote that in this case you cannot specify an extra patch file to\nuse. The git repo must contain all necessary Meson build definitions.\nUsually you would use subprojects as read only. However in some cases\nyou want to do commits to subprojects and push them upstream. For\nthese cases you can specify the upload URL by adding the following at\nthe end of your wrap file:\nIf the git repo contains submodules, you can tell Meson to clone them\nautomatically by adding the following (since 0.48.0):\nSetting the clone depth is supported using the depth directive (since 0.52.0).\nNote that git always allow shallowly cloning branches, but in order to clone commit ids\nshallowly, the server must support uploadpack.allowReachableSHA1InWant=true.\nWraps provide a convenient way of obtaining a project into your subproject directory.\nThen you use it as a regular subproject (see subprojects).\nUsually you don't want to write your wraps by hand.\nThere is an online repository called WrapDB that provides\nmany dependencies ready to use. You can read more about WrapDB here.\nThere is also a Meson subcommand to get and manage wraps (see using wraptool).\n\nwrap-file\nwrap-file with Meson build patch\nwrap-git\n\n"});