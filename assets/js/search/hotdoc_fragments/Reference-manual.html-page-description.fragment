fragment_downloaded_cb({"url": "Reference-manual.html#page-description", "fragment": "The following functions are available in build files. Click on each to see the description and usage. The objects returned by them are list afterwards. \nAdds the positional arguments to the compiler command line. This function has two keyword arguments \nlanguage specifies the language s that the arguments should be applied to. If a list of languages is given the arguments are added to each of the corresponding compiler command lines. Note that there is no way to remove an argument set in this way. If you have an argument that is only used in a subset of targets you have to specify it in per target flags. \nnative is a boolean specifying whether the arguments should be applied to the native or cross compilation. If true the arguments will only be used for native compilations. If false the arguments will only be used in cross compilations. If omitted the flags are added to native compilations if compiling natively and cross compilations only when cross compiling. Available since \nThe arguments are used in all compiler invocations with the exception of compile tests because you might need to run a compile test with and without the argument in question. For this reason only the arguments explicitly specified are used during compile tests. \nNote Usually you should use add_project_arguments instead because that works even when you project is used as a subproject. \nNote You must pass always arguments individually arg1 arg2 rather than as a string arg1 arg2 \nLike add_global_arguments but the arguments are passed to the linker. \nAdd support for new programming languages. Equivalent to having them in the project declaration. This function is usually used to add languages that are only used on some platforms like this \nTakes one keyword argument required. It defaults to true which means that if any of the languages specified is not found Meson will halt. Returns true if all languages specified were found and false otherwise. Since the value of a feature option can also be passed to the required keyword argument. \nThis function behaves in the same way as add_global_arguments except that the arguments are only used for the current project they won t be used in any other subproject. \nLike add_project_arguments but the arguments are passed to the linker. \nAdd a custom test setup that can be used to run the tests with a custom setup for example under Valgrind. The keyword arguments are the following \nTo use the test setup run meson test setup name inside the build dir. \nNote that all these options are also available while running the meson test script for running tests instead of ninja test or msbuild RUN_TESTS.vcxproj etc depending on the backend. \nAbort with an error message if condition evaluates to false. \nCreates a benchmark item that will be run when the benchmark target is run. The behavior of this function is identical to test with the exception that there is no is_parallel keyword because benchmarks are never run in parallel. \nBuilds both a static and shared library with the given sources. Positional and keyword arguments are otherwise the same as for library. Source files will be compiled only once and object files will be reused to build both shared and static libraries unless b_staticpic user option or pic argument are set to false in which case sources will be compiled twice. \nThe returned buildtarget always represents the shared library. In addition it supports the following extra methods \nAdded \nCreates a build target whose type can be set dynamically with the target_type keyword argument. This declaration \nis equivalent to this \nThe object returned by build_target and all convenience wrappers for build_target such as executable and library has methods that are documented in the object methods section below. \nCreates an empty configuration object. You should add your configuration with its method calls and finally use it in a call to configure_file. \nSince takes an optional dictionary as first argument. If provided each key value pair is added into the configuration_data as if set method was called for each of them. \nThis function can run in three modes depending on the keyword arguments passed to it. \nWhen a configuration_data object is passed to the configuration keyword argument it takes a template file as the input optional and produces the output required by substituting values from the configuration data as detailed in the configuration file documentation. Since a dictionary can be passed instead of a configuration_data object. \nWhen a list of strings is passed to the command keyword argument it takes any source or configured file as the input and assumes that the output is produced when the specified command is run. \nSince when the copy keyword argument is set to true this function will copy the file provided in input to a file in the build directory with the name output in the current directory. \nThese are all the supported keyword arguments \nCreate a custom top level build target. The only positional argument is the name of this target and the keyword arguments are the following. \nThe list of strings passed to the command keyword argument accept the following special string substitutions \nThe depfile keyword argument also accepts the BASENAME and PLAINNAME substitutions. since \nThe returned object also has methods that are documented in the object methods section below. \nThis function returns a dependency object that behaves like the return value of dependency but is internal to the current build. The main use case for this is in subprojects. This allows a subproject to easily specify how it should be used. This makes it interchangeable with the same dependency that is provided externally by the system. This function has the following keyword arguments. \nFinds an external dependency usually a library installed on your system with the given name with pkg config if possible as a framework OSX only and with library specific fallback detection logic otherwise. This function supports the following keyword arguments \nIf dependency_name is the dependency is always not found. So with required false this always returns a dependency object for which the found method returns false and which can be passed like any other dependency to the dependencies keyword argument of a build_target. This can be used to implement a dependency which is sometimes not required e.g. in some branches of a conditional. \nThe returned object also has methods that are documented in the object methods section below. \nReturns a disabler object. Added in \nPrint the argument string and halts the build process. \nReturns an empty environment variable object. \nCreates a new executable. The first argument specifies its name and the remaining positional arguments define the input files to use. They can be of the following types \nThese input files can be sources objects libraries or any other file. Meson will automatically categorize them based on the extension and use them accordingly. For instance sources c cpp vala rs etc will be compiled and objects o obj and libraries so dll etc will be linked. \nWith the Ninja backend Meson will create a build time order only dependency on all generated input files including unknown files. For all input files generated and non generated Meson uses the dependency file generated by your compiler to determine when to rebuild sources. The behavior is similar for other backends. \nExecutable supports the following keyword arguments. Note that just like the positional arguments above these keyword arguments can also be passed to shared and static libraries. \nThe list of sources objects and dependencies is always flattened which means you can freely nest and add lists while creating the final list. \nThe returned object also has methods that are documented in the object methods section below. \nThis function is deprecated and in the release it was moved to the compiler object as obtained from meson.get_compiler lang \nprogram_name1 here is a string that can be an executable or script to be searched for in PATH or a script in the current source directory. \nprogram_name2 and later positional arguments are used as fallback strings to search for. This is meant to be used for cases where the program may have many alternative names such as foo and foo.py. The function will check for the arguments one by one and the first one that is found is returned. Meson versions earlier than only accept one argument. \nKeyword arguments are the following \nrequired By default required is set to true and Meson will abort if no program can be found. If required is set to false Meson continue even if none of the programs can be found. You can then use the found method on the returned object to check whether it was found or not. Since the value of a feature option can also be passed to the required keyword argument. \nnative since defines how this executable should be searched. By default it is set to false which causes Meson to first look for the executable in the cross file when cross building and if it is not defined there then from the system. If set to true the cross file is ignored and the program is only searched from the system. \nMeson will also autodetect scripts with a shebang line and run them with the executable interpreter specified in it both on Windows because the command invocator will reject the command otherwise and Unixes if the script file does not have the executable bit set Hence you must not manually add the interpreter while using this script as part of a list of commands. \nIf you need to check for a program in a non standard location you can just pass an absolute path to find_program e.g. setcap find_program setcap usr sbin setcap sbin setcap required false \nIt is also possible to pass an array to find_program in case you need to construct the set of paths to search on the fly \nThe returned object also has methods that are documented in the object methods section below. \nThis command takes the strings given to it in arguments and returns corresponding File objects that you can use as sources for build targets. The difference is that file objects remember the subdirectory they were defined in and can be used anywhere in the source tree. As an example suppose you have source file foo.cpp in subdirectory bar1 and you would like to use it in a build target that is defined in bar2. To make this happen you first create the object in bar1 like this \nThen you can use it in bar2 like this \nMeson will then do the right thing. \nSee also custom_target \nThis function creates a generator object that can be used to run custom compilation commands. The only positional argument is the executable to use. It can either be a self built executable or one returned by find_program. Keyword arguments are the following \nThe returned object also has methods that are documented in the object methods section below. \nThe template strings passed to all the above keyword arguments accept the following special substitutions \nEach string passed to the output keyword argument must be constructed using one or both of these two substitutions. \nIn addition to the above substitutions the arguments keyword argument also accepts the following \nNOTE Generators should only be used for outputs that will only be used as inputs for a build target or a custom target. When you use the processed output of a generator in multiple targets the generator will be run multiple times to create outputs for each target. Each output will be created in a target private directory BUILD_DIR \nIf you want to generate files for general purposes such as for generating headers to be used by several sources or data that will be installed and so on use a custom_target instead. \nObtains the value of the project build option specified in the positional argument. \nNote that the value returned for built in options that end in dir such as bindir and libdir is always a path relative to and inside the prefix. \nThe only exceptions are sysconfdir localstatedir and sharedstatedir which will return the value passed during configuration as is which may be absolute or relative to prefix. install_dir arguments handles that as expected but if you need the absolute path to one of these e.g. to use in a define etc. you should use join_paths get_option prefix get_option localstatedir \nFor options of type feature a special object is returned instead of a string. See feature options documentation for more details. \nThis function can be used to dynamically obtain a variable. res get_variable varname fallback takes the value of varname which must be a string and stores the variable of that name into res. If the variable does not exist the variable fallback is stored to resinstead. If a fallback is not specified then attempting to read a non existing variable will cause a fatal error. \nImports the given extension module. Returns an opaque object that can be used to call the methods of the module. Here s an example for a hypothetical testmod module. \nReturns an opaque object which contains the directories relative to the current directory given in the positional arguments. The result can then be passed to the include_directories keyword argument when building executables or libraries. You can use the returned object in any subdirectory you want Meson will make the paths work automatically. \nNote that this function call itself does not add the directories into the search path since there is no global search path. For something like that see add_project_arguments \nSee also implicit_include_directories parameter of executable which adds current source and build directories to include path. \nEach directory given is converted to two include paths one that is relative to the source root and one relative to the build root. \nFor example with the following source tree layout in home user project.git \nmeson.build \ninclude meson.build \nsrc meson.build \nIf the build tree is tmp build tree the following include paths will be added to the executable call I tmp build tree include I home user project.git include. \nThis function has one keyword argument is_system which if set flags the specified directories as system directories. This means that they will be used with the isystem compiler argument rather than I on compilers that support this flag in practice everything except Visual Studio \nInstalls files from the source tree that are listed as positional arguments. The following keyword arguments are supported \ninstall_dir the absolute or relative path to the installation directory. If this is a relative path it is assumed to be relative to the prefix. \nIf omitted the directory defaults to datadir projectname added \ninstall_mode specify the file mode in symbolic format and optionally the owner uid and group gid for the installed files. For example \ninstall_mode rw r r for just the file mode \ninstall_mode rw r r nobody nobody for the file mode and the user group \ninstall_mode rw r for the file mode and uid gid \nTo leave any of these three as the default specify false. \nSee Installing for more examples. \nInstalls the specified header files from the source tree into the system header directory usually prefix include during the install step. This directory can be overridden by specifying it with the install_dir keyword argument. If you just want to install into a subdirectory of the system header directory then use the subdir argument. As an example if this has the value myproj then the headers would be installed to prefix include myproj. \nFor example this will install common.h and kola.h into prefix include \nThis will install common.h and kola.h into prefix include myproj \nThis will install common.h and kola.h into prefix cust myproj \nThe install_mode argument can be used to specify the file mode in symbolic format and optionally the owner uid and group gid for the installed files. An example value could be rwxr sr x root root Added \nInstalls the specified man files from the source tree into system s man directory during the install step. This directory can be overridden by specifying it with the install_dir keyword argument. All man pages are compressed during installation and installed with a gz suffix. \nThe install_mode argument can be used to specify the file mode in symbolic format and optionally the owner uid and group gid for the installed files. An example value could be rwxr sr x root root Added \nInstalls the entire given subdirectory and its contents from the source tree to the location specified by the keyword argument install_dir. \nThe following keyword arguments are supported \nFor a given directory foo \ninstall_subdir foo install_dir share strip_directory false creates \ninstall_subdir foo install_dir share strip_directory true creates \ninstall_subdir foo bar install_dir share strip_directory false creates \ninstall_subdir foo bar install_dir share strip_directory true creates \nReturns true if a variable of the given name exists and false otherwise. \nBuild a jar from the specified Java source files. Keyword arguments are the same as executable s with the addition of main_class which specifies the main class to execute when running the jar with java jar file.jar. \nJoins the given strings into a file system path segment. For example join_paths foo bar results in foo bar. If any one of the individual segments is an absolute path all segments before it are dropped. That means that join_paths foo bar returns bar. \nAdded \nBuilds a library that is either static shared or both depending on the value of default_library user option. You should use this instead of shared_library static_library or both_libraries most of the time. This allows you to toggle your entire project including subprojects from shared to static with only one option. \nThe keyword arguments for this are the same as for executable with the following additions \nstatic_library shared_library and both_libraries also accept these keyword arguments. \nNote You can set name_prefix and name_suffix to or omit them for the default behaviour for each platform. \nThis function prints its argument to stdout. \nThis function prints its argument to stdout prefixed with WARNING \nAdded \nThe first argument to this function must be a string defining the name of this project. It is followed by programming languages that the project uses. Supported values for languages are c cpp for C d objc objcpp fortran java cs for C and vala. In versions before you must have at least one language listed. \nThe project name can be any string you want it s not used for anything except descriptive purposes. However since it is written to e.g. the dependency manifest is usually makes sense to have it be the same as the project tarball or pkg config name. So for example you would probably want to use the name libfoobar instead of The Foobar Library. \nProject supports the following keyword arguments. \nlicense takes a string or array of strings describing the license s the code is under. Usually this would be something like license GPL2 but if the code has multiple licenses you can specify them as an array like this license proprietary GPL3 Note that the text is informal and is only written to the dependency manifest. Meson does not do any license validation you are responsible for verifying that you abide by all licensing terms. You can access the value in your Meson build files with meson.project_license \nmeson_version takes a string describing which Meson version the project requires. Usually something like \nsubproject_dir specifies the top level directory name that holds Meson subprojects. This is only meant as a compatibility option for existing code bases that house their embedded source code in a custom directory. All new projects should not set this but instead use the default value. It should be noted that this keyword argument is ignored inside subprojects. There can be only one subproject dir and it is set in the top level Meson file. \nversion which is a free form string describing the version of this project. You can access the value in your Meson build files with meson.project_version \nRuns the command specified in positional arguments. command can be a string or the output of find_program files or configure_file or a compiler object. \nReturns an opaque object containing the result of the invocation. The command is run from an unspecified directory and Meson will set three environment variables MESON_SOURCE_ROOT MESON_BUILD_ROOT and MESON_SUBDIR that specify the source directory build directory and subdirectory the target was defined in respectively. \nThis function has one keyword argument. \nSee also External commands. \nThis function creates a new top level target that runs a specified command with the specified arguments. Like all top level targets this integrates with the selected backend. For instance with Ninja you can run it as ninja target_name. Note that a run target produces no output as far as Meson is concerned. It is only meant for tasks such as running a code formatter or flashing an external device s firmware with a built file. \nThe command is run from an unspecified directory and Meson will set three environment variables MESON_SOURCE_ROOT MESON_BUILD_ROOT and MESON_SUBDIR that specify the source directory build directory and subdirectory the target was defined in respectively. \nAssigns a value to the given variable name. Calling set_variable foo bar is equivalent to foo bar. \nNote Prior to v0.46.1 the value parameter could not be an array type due to flattening of the function parameters. \nBuilds a shared library with the given sources. Positional and keyword arguments are the same as for library with the following extra keyword arguments. \nBuilds a shared module with the given sources. Positional and keyword arguments are the same as for library. \nThis is useful for building modules that will be dlopen ed and hence may contain undefined symbols that will be provided by the library that is loading it. \nIf you want the shared module to be able to refer to functions and variables defined in the executable it is loaded by you will need to set the export_dynamic argument of the executable to true. \nNote Linking to a shared module is not supported on some platforms notably OSX. Consider using a shared_library instead if you need to both dlopen and link with a library. \nAdded \nBuilds a static library with the given sources. Positional and keyword arguments are otherwise the same as for library but it has one argument the others don t have \nEnters the specified subdirectory and executes the meson.build file in it. Once that is done it returns and execution continues on the line following this subdir command. Variables defined in that meson.build file are then available for use in later parts of the current build file and in all subsequent build files executed with subdir \nNote that this means that each meson.build file in a source tree can and must only be executed once. \nThis function has one keyword argument. \nStops further interpretation of the meson script file from the point of the invocation. All steps executed up to this point are valid and will be executed by meson. This means that all targets defined before the call of subdir_done will be build. \nIf the current script was called by subdir the execution returns to the calling directory and continues as if the script had reached the end. If the current script is the top level script meson configures the project as defined up to this point. \nExample \nThe executable exe1 will be build while the executable exe2 is not build. \nTakes the project specified in the positional argument and brings that in the current build specification by returning a subproject object. Subprojects must always be placed inside the subprojects directory at the top source directory. So for example a subproject called foo must be located in MESON_SOURCE_ROOT subprojects foo. Supports the following keyword arguments \nNote that you can use the returned subproject object to access any variable in the subproject. However if you want to use a dependency object from inside a subproject an easier way is to use the fallback keyword argument to dependency \nSee additional documentation. \nDefines a test to run with the test harness. Takes two positional arguments the first is the name of the test and the second is the executable to run. The executable can be an executable build target object returned by executable or an external program object returned by find_program The executable s exit code is used by the test harness to record the outcome of the test for example exit code zero indicates success. For more on the Meson test harness protocol read Unit Tests. \nKeyword arguments are the following \nargs arguments to pass to the executable \nenv environment variables to set such as NAME1 value1 NAME2 value2 or an environment object which allows more sophisticated environment juggling \nis_parallel when false specifies that no other test must be running at the same time as this test \nshould_fail when true the test is considered passed if the executable returns a non zero return value i.e. reports an error \nsuite label or list of labels label1 label2 attached to this test. The suite name is qualified by a sub project name resulting in sub project_name label. In the case of a list of strings the suite names will be sub project_name label1 sub project_name label2 etc. \ntimeout the amount of seconds the test is allowed to run a test that exceeds its time limit is always considered failed defaults to seconds \nworkdir absolute path that will be used as the working directory for the test \ndepends specifies that this test depends on the specified target s even though it does not take any of them as a command line argument. This is meant for cases where test finds those targets internally e.g. plugins or globbing. Those targets are built before test is executed even if they have build_by_default false. Since \nDefined tests can be run in a backend agnostic way by calling meson test inside the build dir or by using backend specific commands such as ninja test or msbuild RUN_TESTS.vcxproj. \nThis command detects revision control commit information at build time and places it in the specified output file. This file is guaranteed to be up to date on every build. Keywords are similar to custom_target. \nMeson will read the contents of input substitute the replace_string with the detected revision number and write the result to output. This method returns a custom_target object that as usual should be used to signal dependencies if other targets use the file outputted by this. \nFor example if you generate a header with this and want to use that in a build target you must add the return value to the sources of that build target. Without that Meson will not know the order in which to build the targets. \nIf you desire more specific behavior than what this command provides you should use custom_target. \nThese are built in objects that are always available. \nThe meson object allows you to introspect various properties of the system. This object is always mapped in the meson variable. It has the following methods. \nadd_dist_script script_name arg1 arg causes the script given as argument to run during dist operation after the distribution source has been generated but before it is archived. Note that this runs the script file that is in the staging directory not the one in the source directory. If the script file can not be found in the staging directory it is a hard error. This command can only invoked from the main project calling it from a subproject is a hard error. Available since Before the function only accepted a single argument. \nadd_install_script script_name arg1 arg2 causes the script given as an argument to be run during the install step this script will have the environment variables MESON_SOURCE_ROOT MESON_BUILD_ROOT MESON_INSTALL_PREFIX MESON_INSTALL_DESTDIR_PREFIX and MESONINTROSPECT set. All additional arguments are passed as parameters. \nMeson uses the DESTDIR environment variable as set by the inherited environment to determine the temporary installation location for files. Your install script must be aware of this while manipulating and installing files. The correct way to handle this is with the MESON_INSTALL_DESTDIR_PREFIX variable which is always set and contains DESTDIR if set and prefix joined together. This is useful because both are usually absolute paths and there are platform specific edge cases in joining two absolute paths. \nIn case it is needed MESON_INSTALL_PREFIX is also always set and has the value of the prefix option passed to Meson. \nMESONINTROSPECT contains the path to the introspect command that corresponds to the meson executable that was used to configure the build. This might be a different path then the first executable found in PATH. It can be used to query build configuration. Note that the value will contain many parts f.ex. it may be python3 path to meson.py introspect. The user is responsible for splitting the string to an array if needed by splitting lexically like a UNIX shell would. If your script uses Python shlex.split is the easiest correct way to do this. \nadd_postconf_script script_name arg1 arg2 will run the executable given as an argument after all project files have been generated. This script will have the environment variables MESON_SOURCE_ROOT and MESON_BUILD_ROOT set. \nbackend added returns a string representing the current backend ninja vs2010 vs2015 vs2017 or xcode. \nbuild_root returns a string with the absolute path to the build root directory. Note this function will return the build root of the parent project if called from a subproject which is usually not what you want. Try using current_build_dir \nsource_root returns a string with the absolute path to the source root directory. Note you should use the files function to refer to files in the root source directory instead of constructing paths manually with meson.source_root This function will return the source root of the parent project if called from a subproject which is usually not what you want. Try using current_source_dir \ncurrent_build_dir returns a string with the absolute path to the current build directory. \ncurrent_source_dir returns a string to the current source directory. Note you do not need to use this function when passing files from the current source directory to a function since that is the default. Also you can use the files function to refer to files in the current or any other source directory instead of constructing paths manually with meson.current_source_dir \nget_cross_property propname fallback_value returns the given property from a cross file the optional second argument is returned if not cross compiling or the given property is not found. \nget_compiler language returns an object describing a compiler takes one positional argument which is the language to use. It also accepts one keyword argument native which when set to true makes Meson return the compiler for the build machine the native compiler and when false it returns the host compiler the cross compiler If native is omitted Meson returns the cross compiler if we re currently cross compiling and the native compiler if we re not. \nhas_exe_wrapper returns true when doing a cross build if there is a wrapper command that can be used to execute cross built binaries for example when cross compiling from Linux to Windows one can use wine as the wrapper \ninstall_dependency_manifest output_name installs a manifest file containing a list of all subprojects their versions and license files to the file name given as the argument. \nis_cross_build returns true if the current build is a cross build and false otherwise. \nis_subproject returns true if the current project is being built as a subproject of some other project and false otherwise. \nis_unity returns true when doing a unity build multiple sources are combined before compilation to reduce build time and false otherwise. \noverride_find_program progname program Added specifies that whenever find_program is used to find a program named progname Meson should not not look it up on the system but instead return program which may either be the result of find_program configure_file or executable. \nIf program is an executable it cannot be used during configure. \nproject_version returns the version string specified in project function call. \nproject_license returns the array of licenses specified in project function call. \nproject_name returns the project name specified in the project function call. \nversion return a string with the version of Meson. \nProvides information about the build machine the machine that is doing the actual compilation. See Cross compilation. It has the following methods \ncpu_family returns the CPU family name. This table contains all known CPU families. These are guaranteed to continue working. \ncpu returns a more specific CPU name such as i686 amd64 etc. \nsystem returns the operating system name. This table Lists all of the currently known Operating System names these are guaranteed to continue working. \nendian returns big on big endian systems and little on little endian systems. \nCurrently these values are populated using platform.system and platform.machine If you think the returned values for any of these are incorrect for your system or CPU or if your OS is not in the linked table please file a bug report with details and we ll look into it. \nProvides information about the host machine the machine on which the compiled binary will run. See Cross compilation. \nIt has the same methods as build_machine. \nWhen not cross compiling all the methods return the same values as build_machine because the build machine is the host machine \nNote that while cross compiling it simply returns the values defined in the cross info file. \nProvides information about the target machine the machine on which the compiled binary s output will run. Hence this object should only be used while cross compiling a compiler. See Cross compilation. \nIt has the same methods as build_machine. \nWhen all compilation is native all the methods return the same values as build_machine because the build machine is the host machine and the target machine \nNote that while cross compiling it simply returns the values defined in the cross info file. If target_machine values are not defined in the cross info file host_machine values are returned instead. \nThis object is returned by meson.get_compiler lang It represents a compiler for a given language and allows you to query its properties. It has the following methods \nalignment typename returns the alignment of the type specified in the positional argument you can specify external dependencies to use with dependencies keyword argument. \ncmd_array returns an array containing the command arguments for the current compiler. \ncompiles code returns true if the code fragment given in the positional argument compiles you can specify external dependencies to use with dependencies keyword argument code can be either a string containing source code or a file object pointing to the source code. \ncompute_int expr computes the value of the given expression as an example When cross compiling this is evaluated with an iterative algorithm you can specify keyword arguments low defaults to high defaults to and guess to specify max and min values for the search and the value to try first. \nfind_library lib_name tries to find the library specified in the positional argument. The result object can be used just like the return value of dependency. If the keyword argument required is false Meson will proceed even if the library is not found. By default the library is searched for in the system library directory e.g. usr lib This can be overridden with the dirs keyword argument which can be either a string or a list of strings. Since the value of a feature option can also be passed to the required keyword argument. \nfirst_supported_argument list_of_strings given a list of strings returns the first argument that passes the has_argument test or an empty array if none pass. \nfirst_supported_link_argument list_of_strings added given a list of strings returns the first argument that passes the has_link_argument test or an empty array if none pass. \nget_define definename returns the given preprocessor symbol s value as a string or empty string if it is not defined. Starting with this method will concatenate string literals as the compiler would. E.g. a b will become ab \nget_id returns a string identifying the compiler. For example gcc msvc and more. \nget_supported_arguments list_of_string added returns an array containing only the arguments supported by the compiler as if has_argument were called on them individually. \nget_supported_link_arguments list_of_string added returns an array containing only the arguments supported by the linker as if has_link_argument were called on them individually. \nhas_argument argument_name returns true if the compiler accepts the specified command line argument that is can compile code without erroring out or printing a warning about an unknown flag. \nhas_link_argument argument_name added returns true if the linker accepts the specified command line argument that is can compile and link code without erroring out or printing a warning about an unknown flag. Link arguments will be passed to the compiler so should usually have the Wl prefix. On VisualStudio a link argument will be prepended. \nhas_function funcname returns true if the given function is provided by the standard library or a library passed in with the args keyword you can specify external dependencies to use with dependencies keyword argument. \ncheck_header added returns true if the specified header is usable with the specified prefix dependencies and arguments. You can specify external dependencies to use with dependencies keyword argument and extra code to put above the header test with the prefix keyword. In order to look for headers in a specific directory you can use args I extra include dir but this should only be used in exceptional cases for includes that can t be detected via pkg config and passed via dependencies. \nhas_header returns true if the specified header exists and is faster than check_header since it only does a pre processor check. You can specify external dependencies to use with dependencies keyword argument and extra code to put above the header test with the prefix keyword. In order to look for headers in a specific directory you can use args I extra include dir but this should only be used in exceptional cases for includes that can t be detected via pkg config and passed via dependencies. \nhas_header_symbol headername symbolname allows one to detect whether a particular symbol function variable define type definition etc is declared in the specified header you can specify external dependencies to use with dependencies keyword argument. \nhas_member typename membername takes two arguments type name and member name and returns true if the type has the specified member you can specify external dependencies to use with dependencies keyword argument. \nhas_members typename membername1 membername2 takes at least two arguments type name and one or more member names returns true if the type has all the specified members you can specify external dependencies to use with dependencies keyword argument. \nhas_multi_arguments arg1 arg2 arg3 is the same as has_argument but takes multiple arguments and uses them all in a single compiler invocation available since \nhas_multi_link_arguments arg1 arg2 arg3 added is the same as has_link_argument but takes multiple arguments and uses them all in a single compiler invocation. \nhas_type typename returns true if the specified token is a type you can specify external dependencies to use with dependencies keyword argument. \nlinks code returns true if the code fragment given in the positional argument compiles and links you can specify external dependencies to use with dependencies keyword argument code can be either a string containing source code or a file object pointing to the source code. \nrun code attempts to compile and execute the given code fragment returns a run result object you can specify external dependencies to use with dependencies keyword argument code can be either a string containing source code or a file object pointing to the source code. \nsymbols_have_underscore_prefix returns true if the C symbol mangling is one underscore _ prefixed to the symbol available since \nsizeof typename returns the size of the given type e.g. int or if the type is unknown to add includes set them in the prefix keyword argument you can specify external dependencies to use with dependencies keyword argument. \nversion returns the compiler s version number as a string. \nhas_function_attribute name added in returns true if the compiler supports the GNU style __attribute__ name. This is preferable to manual compile checks as it may be optimized for compilers that do not support such attributes. This table Lists all of the supported attributes. \nget_supported_function_attributes list_of_names added in returns an array containing any names that are supported GCC style attributes. Equivalent to has_function_attribute was called on each of them individually. \nThe following keyword arguments can be used \nargs can be used to pass a list of compiler arguments that are required to find the header or symbol. For example you might need to pass the include path Isome path to header if a header is not in the default include path. In versions newer than you should use the include_directories keyword described above. You may also want to pass a library name lfoo for has_function to check for a function. Supported by all methods except get_id version and find_library. \ninclude_directories specifies extra directories for header searches. added \nname the name to use for printing a message about the compiler check. Supported by the methods compiles links and run If this keyword argument is not passed to those methods no message will be printed about the check. \nprefix can be used to add includes and other things that are required for the symbol to be declared. System definitions should be passed via compiler args eg _GNU_SOURCE is often required for some symbols to be exposed on Linux and it should be passed via args keyword argument see below Supported by the methods sizeof has_type has_function has_member has_members check_header has_header has_header_symbol. \nNote These compiler checks do not use compiler arguments added with add_ _arguments via Dlang_args on the command line or through CFLAGS LDFLAGS etc in the environment. Hence you can trust that the tests will be fully self contained and won t fail because of custom flags added by other parts of the build file or by users. \nNote that if you have a single prefix with all your dependencies you might find it easier to append to the environment variables C_INCLUDE_PATH with GCC Clang and INCLUDE with MSVC to expand the default include path and LIBRARY_PATH with GCC Clang and LIB with MSVC to expand the default library search path. \nHowever with GCC these variables will be ignored when cross compiling. In that case you need to use a specs file. See http www.mingw.org wiki SpecsFileHOWTO \nAll strings have the following methods. Strings are immutable all operations return their results as a new string. \ncontains string returns true if string contains the string specified as the argument \nendswith string returns true if string ends with the string specified as the argument \nformat formats text see the Syntax manual for usage info \njoin list_of_strings is the opposite of split for example join a b c yields a.b.c \nsplit split_character splits the string at the specified character or whitespace if not set and returns the parts in an array \nstartswith string returns true if string starts with the string specified as the argument \nstrip removes whitespace at the beginning and end of the string added optionally can take one positional string argument and all characters in that string will be stripped \nto_int returns the string converted to an integer error if string is not a number \nto_lower creates a lower case version of the string \nto_upper creates an upper case version of the string \nunderscorify creates a string where every non alphabetical non number character is replaced with _ \nversion_compare comparison_string does semantic version comparison if x then x.version_compare returns true \nNumbers support these methods \nA boolean object has two simple methods \nto_int as above but returns either or \nto_string returns the string true if the boolean is true or false otherwise. You can also pass it two strings as positional arguments to specify what to return for true false. For instance bool.to_string yes no will return yes if the boolean is true and no if it is false. \nThe following methods are defined for all arrays \ncontains item returns true if the array contains the object given as argument false otherwise \nget index fallback returns the object at the given index negative indices count from the back of the array indexing out of bounds returns the fallback value added or if it is not specified causes a fatal error \nlength the size of the array \nYou can also iterate over arrays with the foreach statement. \nThe following methods are defined for all dictionaries \nhas_key key returns true if the dictionary contains the key given as argument false otherwise \nget key fallback returns the value for the key given as first argument if it is present in the dictionary or the optional fallback value given as the second argument. If a single argument was given and the key was not found causes a fatal error \nYou can also iterate over dictionaries with the foreach statement. \nDictionaries are available since \nSince dictionaries can be added e.g. d1 d2 d3 and d1 d2 Values from the second dictionary overrides values from the first. \nThese are objects returned by the functions listed above. \nA build target is either an executable shared library static library both shared and static library or shared module. \nextract_all_objects is same as extract_objects but returns all object files generated by this target. Since keyword argument recursive must be set to true to also return objects passed to the object argument of this target. By default only objects built for this target are returned to maintain backward compatibility with previous versions. The default will eventually be changed to true in a future version. \nextract_objects returns an opaque value representing the generated object files of arguments usually used to take single object files and link them to unit tests or to compile some source files with custom flags. To use the object file s in another build target use the objects keyword argument. \nfull_path returns a full path pointing to the result target file. NOTE In most cases using the object itself will do the same job as this and will also allow Meson to setup inter target dependencies correctly. Please file a bug if that doesn t work for you. \nprivate_dir_include returns a opaque value that works like include_directories but points to the private directory of this target usually only needed if an another target needs to access some generated internal headers of this target \nThis object is returned by configuration_data and encapsulates configuration values to be used for generating configuration files. A more in depth description can be found in the the configuration wiki page It has three methods \nget varname default_value returns the value of varname if the value has not been set returns default_value if it is defined added and errors out if not \nget_unquoted varname default_value returns the value of varname but without surrounding double quotes If the value has not been set returns default_value if it is defined and errors out if not. Available since \nhas varname returns true if the specified variable is set \nmerge_from other takes as argument a different configuration data object and copies all entries from that object to the current object available since \nset varname value sets a variable to a given value \nset10 varname boolean_value is the same as above but the value is either true or false and will be written as or respectively \nset_quoted varname value is same as set but quotes the value in double quotes \nThey all take the description keyword that will be written in the result file. The replacement assumes a file with C syntax. If your generated file is source code in some other language you probably don t want to add a description field because it most likely will cause a syntax error. \nThis object is returned by custom_target and contains a target with the following methods \nfull_path returns a full path pointing to the result target file NOTE In most cases using the object itself will do the same job as this and will also allow Meson to setup inter target dependencies correctly. Please file a bug if that doesn t work for you. \nindex returns an opaque object that references this target and can be used as a source in other targets. When it is used as such it will make that target depend on this custom target but the only source added will be the one that corresponds to the index of the custom target s output argument. \nThis object is returned by dependency and contains an external dependency with the following methods \nfound which returns whether the dependency was found \nget_pkgconfig_variable varname Added will get the pkg config variable specified or if invoked on a non pkg config dependency error out. Added You can also redefine a variable by passing a list to the define_variable parameter that can affect the retrieved variable prefix Added A warning is issued if the variable is not defined unless a default parameter is specified. \nget_configtool_variable varname Added will get the command line argument from the config tool with prepended or if invoked on a non config tool dependency error out. \ntype_name which returns a string describing the type of the dependency the most common values are internal for deps created with declare_dependency and pkgconfig for system dependencies obtained with Pkg config. \nversion is the version number as a string for example unknown if the dependency provider doesn t support determining the version. \npartial_dependency compile_args false link_args false links false includes false source false added returns a new dependency object with the same name version found status type name and methods as the object that called it. This new object will only inherit other attributes from its parent as controlled by keyword arguments. \nIf the parent has any dependencies those will be applied to the new partial dependency with the same rules. So given \ndep3 will add Werror foo Werror bar to the compiler args of any target it is added to but libfoo will not be added to the link_args. \nThe following arguments will add the following attributes \nA disabler object is an object that behaves in much the same way as NaN numbers do in floating point math. That is when used in any statement function call logical op etc they will cause the statement evaluation to immediately short circuit to return a disabler object. A disabler object has one method \nThis object is returned by find_program and contains an external i.e. not built as part of this project program and has the following methods \nfound which returns whether the executable was found \npath which returns a string pointing to the script or executable NOTE You should not need to use this method. Passing the object itself should work in all cases. F.ex. run_command obj arg1 arg2 \nThis object is returned by environment and stores detailed information about how environment variables should be set during tests. It should be passed as the env keyword argument to tests. It has the following methods. \nappend varname value1 value2 appends the given values to the old value of the environment variable e.g. env.append FOO BAR BAZ separator produces BOB BAR BAZ if FOO had the value BOB and plain BAR BAZ if the value was not defined. If the separator is not specified explicitly the default path separator for the host operating system will be used i.e. for Windows and for UNIX POSIX systems. \nprepend varname value1 value2 is the same as append except that it writes to the beginning of the variable \nset varname value1 value2 sets the environment variable specified in the first argument to the values in the second argument joined by the separator e.g. env.set FOO BAR sets envvar FOO to value BAR. See append above for how separators work. \nNote All these methods overwrite the previously defined value s if called twice with the same varname. \nThis object is returned by find_library and contains an external i.e. not built as part of this project library. This object has the following methods \nfound which returns whether the library was found. \ntype_name added which returns a string describing the type of the dependency which will be library in this case. \npartial_dependency compile_args false link_args false links false includes false source false added returns a new dependency object with the same name version found status type name and methods as the object that called it. This new object will only inherit other attributes from its parent as controlled by keyword arguments. \nThis object is returned by generator and contains a generator that is used to transform files from one type to another by an executable e.g. idl files into source code and headers \nThis object is returned by subproject and is an opaque object representing it. \nThis object encapsulates the result of trying to compile and run a sample piece of code with compiler.run or run_command It has the following methods \n"});